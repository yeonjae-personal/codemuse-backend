"""
English Formatting Templates

Templates for formatting analysis results in English (for future expansion).
"""

from typing import Dict

from ..options.formatting_options import DetailLevel


class EnglishTemplates:
    """
    English formatting templates class

    Provides different templates based on detail level.
    """

    # Emoji mapping
    EMOJIS = {
        "valid": "âœ…",
        "invalid": "âŒ",
        "warning": "âš ï¸",
        "info": "â„¹ï¸",
        "error": "ðŸš¨",
        "success": "ðŸŽ¯",
        "complexity": "ðŸ“ˆ",
        "performance": "âš¡",
        "quality": "ðŸ†",
        "structure": "ðŸ—ï¸",
        "issues": "ðŸ”",
        "metrics": "ðŸ“Š",
        "summary": "ðŸ“‹",
        "timestamp": "ðŸ•’",
        "bullet": "â€¢",
        "separator": "â”€",
    }

    @classmethod
    def get_template(cls, detail_level: DetailLevel) -> Dict[str, str]:
        """
        Get template based on detail level

        Args:
            detail_level: Detail level

        Returns:
            Template dictionary
        """
        if detail_level == DetailLevel.SIMPLE:
            return cls._get_simple_template()
        elif detail_level == DetailLevel.DETAILED:
            return cls._get_detailed_template()
        else:
            return cls._get_normal_template()

    @classmethod
    def _get_simple_template(cls) -> Dict[str, str]:
        """Simple level template"""
        return {
            "header": "{emoji} Rule Analysis Result",
            "validity": "{emoji} Validation Result: {result}",
            "complexity": "Complexity: {score}/100",
            "issue_count": "Issues: {count}",
            "summary": "Summary: {text}",
        }

    @classmethod
    def _get_normal_template(cls) -> Dict[str, str]:
        """Normal level template"""
        return {
            "header": "{emoji} Rule Analysis Result",
            "separator": "{emoji}",
            "validity": "{emoji} Rule Validation Result: {result}",
            "summary": "{emoji} Summary Information",
            "summary_text": "{text}",
            "complexity": "{emoji} Complexity Score: {score}/100",
            "issue_count": "{emoji} Issues Found: {count}",
            "structure": "{emoji} Structure Analysis",
            "structure_depth": "  â€¢ Max Depth: {depth}",
            "structure_conditions": "  â€¢ Condition Count: {count}",
            "structure_fields": "  â€¢ Unique Fields: {fields}",
            "issues_header": "{emoji} Issue Details",
            "issue_item": "  {emoji} Issue {index}: {type} - {explanation}",
            "performance_header": "{emoji} Performance Metrics",
            "quality_header": "{emoji} Quality Metrics",
            "timestamp": "{emoji} Analysis Time: {time}",
        }

    @classmethod
    def _get_detailed_template(cls) -> Dict[str, str]:
        """Detailed level template"""
        base = cls._get_normal_template()
        detailed = {
            "field_analysis_header": "{emoji} Field Analysis Details",
            "field_item": "  {emoji} {field}: {type} type, {conditions} conditions, {issues} issues",
            "logic_flow_header": "{emoji} Logic Flow Analysis",
            "logic_operators": "  â€¢ Logical Operators: {operators}",
            "nesting_levels": "  â€¢ Nesting Levels: {levels}",
            "branch_coverage": "  â€¢ Branch Coverage: {coverage}",
            "performance_details": "  â€¢ Estimated Execution Time: {time}ms",
            "performance_memory": "  â€¢ Estimated Memory Usage: {memory}KB",
            "performance_rating": "  â€¢ Complexity Rating: {rating}",
            "performance_suggestions": "  â€¢ Optimization Suggestions: {suggestions}",
            "quality_details": "  â€¢ Maintainability: {maintainability}/100",
            "quality_readability": "  â€¢ Readability: {readability}/100",
            "quality_completeness": "  â€¢ Completeness: {completeness}/100",
            "quality_consistency": "  â€¢ Consistency: {consistency}/100",
            "quality_overall": "  â€¢ Overall Quality: {overall}/100",
            "metadata_header": "{emoji} Metadata",
            "metadata_version": "  â€¢ Analysis Version: {version}",
            "metadata_model": "  â€¢ Validation Model: {model}",
            "metadata_generator": "  â€¢ Generated By: {generator}",
            "metadata_time": "  â€¢ Generation Time: {time}",
        }
        base.update(detailed)
        return base

    @classmethod
    def get_emoji(cls, key: str, include_emojis: bool = True) -> str:
        """
        Get emoji

        Args:
            key: Emoji key
            include_emojis: Whether to include emojis

        Returns:
            Emoji string
        """
        if not include_emojis:
            return ""

        return cls.EMOJIS.get(key, "")

    @classmethod
    def get_severity_emoji(cls, severity: str, include_emojis: bool = True) -> str:
        """
        Get emoji based on severity

        Args:
            severity: Severity level
            include_emojis: Whether to include emojis

        Returns:
            Emoji string
        """
        if not include_emojis:
            return ""

        severity_emojis = {
            "error": cls.EMOJIS["error"],
            "warning": cls.EMOJIS["warning"],
            "info": cls.EMOJIS["info"],
        }

        return severity_emojis.get(severity.lower(), "")

    @classmethod
    def get_complexity_emoji(cls, score: int, include_emojis: bool = True) -> str:
        """
        Get emoji based on complexity score

        Args:
            score: Complexity score
            include_emojis: Whether to include emojis

        Returns:
            Emoji string
        """
        if not include_emojis:
            return ""

        if score < 20:
            return "ðŸŸ¢"  # Low
        elif score < 50:
            return "ðŸŸ¡"  # Medium
        elif score < 80:
            return "ðŸŸ "  # High
        else:
            return "ðŸ”´"  # Very High
