"""
English Formatting Templates

Templates for formatting analysis results in English (for future expansion).
"""

from typing import Dict

from ..options.formatting_options import DetailLevel


class EnglishTemplates:
    """
    English formatting templates class

    Provides different templates based on detail level.
    """

    # Emoji mapping
    EMOJIS = {
        "valid": "✅",
        "invalid": "❌",
        "warning": "⚠️",
        "info": "ℹ️",
        "error": "🚨",
        "success": "🎯",
        "complexity": "📈",
        "performance": "⚡",
        "quality": "🏆",
        "structure": "🏗️",
        "issues": "🔍",
        "metrics": "📊",
        "summary": "📋",
        "timestamp": "🕒",
        "bullet": "•",
        "separator": "─",
    }

    @classmethod
    def get_template(cls, detail_level: DetailLevel) -> Dict[str, str]:
        """
        Get template based on detail level

        Args:
            detail_level: Detail level

        Returns:
            Template dictionary
        """
        if detail_level == DetailLevel.SIMPLE:
            return cls._get_simple_template()
        elif detail_level == DetailLevel.DETAILED:
            return cls._get_detailed_template()
        else:
            return cls._get_normal_template()

    @classmethod
    def _get_simple_template(cls) -> Dict[str, str]:
        """Simple level template"""
        return {
            "header": "{emoji} Rule Analysis Result",
            "validity": "{emoji} Validation Result: {result}",
            "complexity": "Complexity: {score}/100",
            "issue_count": "Issues: {count}",
            "summary": "Summary: {text}",
        }

    @classmethod
    def _get_normal_template(cls) -> Dict[str, str]:
        """Normal level template"""
        return {
            "header": "{emoji} Rule Analysis Result",
            "separator": "{emoji}",
            "validity": "{emoji} Rule Validation Result: {result}",
            "summary": "{emoji} Summary Information",
            "summary_text": "{text}",
            "complexity": "{emoji} Complexity Score: {score}/100",
            "issue_count": "{emoji} Issues Found: {count}",
            "structure": "{emoji} Structure Analysis",
            "structure_depth": "  • Max Depth: {depth}",
            "structure_conditions": "  • Condition Count: {count}",
            "structure_fields": "  • Unique Fields: {fields}",
            "issues_header": "{emoji} Issue Details",
            "issue_item": "  {emoji} Issue {index}: {type} - {explanation}",
            "performance_header": "{emoji} Performance Metrics",
            "quality_header": "{emoji} Quality Metrics",
            "timestamp": "{emoji} Analysis Time: {time}",
        }

    @classmethod
    def _get_detailed_template(cls) -> Dict[str, str]:
        """Detailed level template"""
        base = cls._get_normal_template()
        detailed = {
            "field_analysis_header": "{emoji} Field Analysis Details",
            "field_item": "  {emoji} {field}: {type} type, {conditions} conditions, {issues} issues",
            "logic_flow_header": "{emoji} Logic Flow Analysis",
            "logic_operators": "  • Logical Operators: {operators}",
            "nesting_levels": "  • Nesting Levels: {levels}",
            "branch_coverage": "  • Branch Coverage: {coverage}",
            "performance_details": "  • Estimated Execution Time: {time}ms",
            "performance_memory": "  • Estimated Memory Usage: {memory}KB",
            "performance_rating": "  • Complexity Rating: {rating}",
            "performance_suggestions": "  • Optimization Suggestions: {suggestions}",
            "quality_details": "  • Maintainability: {maintainability}/100",
            "quality_readability": "  • Readability: {readability}/100",
            "quality_completeness": "  • Completeness: {completeness}/100",
            "quality_consistency": "  • Consistency: {consistency}/100",
            "quality_overall": "  • Overall Quality: {overall}/100",
            "metadata_header": "{emoji} Metadata",
            "metadata_version": "  • Analysis Version: {version}",
            "metadata_model": "  • Validation Model: {model}",
            "metadata_generator": "  • Generated By: {generator}",
            "metadata_time": "  • Generation Time: {time}",
        }
        base.update(detailed)
        return base

    @classmethod
    def get_emoji(cls, key: str, include_emojis: bool = True) -> str:
        """
        Get emoji

        Args:
            key: Emoji key
            include_emojis: Whether to include emojis

        Returns:
            Emoji string
        """
        if not include_emojis:
            return ""

        return cls.EMOJIS.get(key, "")

    @classmethod
    def get_severity_emoji(cls, severity: str, include_emojis: bool = True) -> str:
        """
        Get emoji based on severity

        Args:
            severity: Severity level
            include_emojis: Whether to include emojis

        Returns:
            Emoji string
        """
        if not include_emojis:
            return ""

        severity_emojis = {
            "error": cls.EMOJIS["error"],
            "warning": cls.EMOJIS["warning"],
            "info": cls.EMOJIS["info"],
        }

        return severity_emojis.get(severity.lower(), "")

    @classmethod
    def get_complexity_emoji(cls, score: int, include_emojis: bool = True) -> str:
        """
        Get emoji based on complexity score

        Args:
            score: Complexity score
            include_emojis: Whether to include emojis

        Returns:
            Emoji string
        """
        if not include_emojis:
            return ""

        if score < 20:
            return "🟢"  # Low
        elif score < 50:
            return "🟡"  # Medium
        elif score < 80:
            return "🟠"  # High
        else:
            return "🔴"  # Very High
